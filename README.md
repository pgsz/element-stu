# 基于 element-ui 源码的学习

由 工程化、官网、组件库、测试和类型声明五部分组成

[学习来源：https://juejin.cn/post/6935977815342841892](https://juejin.cn/post/6935977815342841892)



## 自定义主题


### 一：在线主题编辑器

直接在官网的主题中进行编辑修改下载，在项目中引入使用即可

可视化，简单明了，但无法支持按需加载


### 二： 命令行主题工具

```shell
# 初始化项目目录并安装主题生成工具
mkdir theme && cd theme && npm init -y && npm i element-theme -D

# 安装白垩主题
npm i element-theme-chalk -D

# 初始化变量文件
node_modules/.bin/et -i
```

可能会出现如下错误信息：
![](/myImages/element-error.png)

原因 element-theme 包中依赖了低版本的 graceful-fs，低版本在高版本的 node.js 中不兼容，最简单的解决方案升级 graceful-fs

在项目根目录下创建 `npm-shrinkwrap.json` 文件，并添加：
```json
{
   "dependencies": {
       "graceful-fs": {
           "version": "4.2.2"
       }
   }
}
```
在执行 `npm i` 重新安装依赖，然后执行 `node_modules/.bin/et -i`，之后会生成 `element-variables.scss` 文件

在 `element-variables.scss` 文件中，进行变量的修改、保存

随后进行编译，生成出来都是 CSS 样式文件，文件名和组件名一一对应，支持按需加载（指定组件的样式文件）和全量引入（index.css）

生成未压缩的样式文件
```shell
node_modules/.bin/et --out theme-chalk
```
生成压缩的样式文件
```shell
node_modules/.bin/et --minimize --out theme-chalk
```
帮助命令
```
node_modules/.bin/et --help
```

使用自定义主题：

将新生成的主题目录（theme-chalk）替换掉框架中的 `/packages/theme-chalk`,将老的重命名为 theme-pg ，后续可以使用，

由于新生成的文件和老文件的目录结构不一样，需要更改 examples 和 build 中的样式引入方式（直接搜索 packages/theme-chalk/ ，针对引入方式进行修改即可）

执行 `npm run dev` 启动开发环境，即可查看效果


### 三： 深度样式定制

有些组件的有些样式不属于主题样式，但和设计稿不一致的话，就需要覆写组件和自定义组件的样式


- 将 `/packages/theme-pg/src` 目录下的所有文件删除
- 加入覆写 button 组件的部分样式
    - 在 `/packages/theme-pg/src` 目录下新建 `button.scss` 文件
    ```scss
    // 这里我要把主要按钮的字号改大有些，只是为了演示效果
    .el-button--primary {
      font-size: 24px;
    }
    ``` 
    - 改造 `build/bin/gen-cssfile.js` 脚本
    ```js
    var fs = require('fs');
    var path = require('path');

    function getIndexScssFile(dir) {

      // 文件列表
      const files = fs.readdirSync(dir);

      /**
      * 需要的格式
      * @import 'xxx.scss'
      */

      let importStr = "/* Automatically generated by './build/bin/gen-cssfile.js' */\n";

      // 需要排查的文件
      const excludeFile = ['assets', 'font', 'index.scss', 'base.scss', 'variable.scss'];

      files.forEach(item => {
        if (excludeFile.includes(item) || !/\.scss$/.test(item)) return;

        importStr += `@import "./${item}";\n`;
      });

      // 在 /packages/theme-pg/src/index.scss 中引入所有样式文件
      fs.writeFileSync(path.resolve(dir, 'index.scss'), importStr);
    }

    getIndexScssFile(path.resolve(__dirname, '../../packages/theme-pg/src/'));
    ```
    - 在根目录下执行一下命令
    ```shell
    npm i shelljs -D
    ```
    - 新建 `/build/bin/compose-css-file.js`
    ```js
    /**
     * 负责合并打包之后的两个 css 目录文件（lib/theme-chalk、lib/theme-pg）
     * theme-chalk：主题配置自动生成的
     * theme-pg：自定义/覆写组件样式
     * 最后合并至 theme-chalk 目录下
    */
    const fs = require('fs');
    const fileSave = require('file-save');
    const { resolve: pathResolve } = require('path');
    const shelljs = require('shelljs');

    const themeChalkPath = pathResolve(__dirname, '../../lib/theme-chalk');
    const themeStsUIPath = pathResolve(__dirname, '../../lib/theme-pg');

    let themeChalk = null;
    let themeStsUI = null;

    try {
      themeChalk = fs.readdirSync(themeChalkPath);
      console.log(themeChalk);
    } catch (error) {
      console.log('/lib/theme-chalk 不存在');
      process.exit(1);
    }

    try {
      themeStsUI = fs.readdirSync(themeStsUIPath);
      console.log(themeStsUI);
    } catch (error) {
      console.log('/lib/theme-pg 不存在');
      process.exit(1);
    }

    const excludeFiles = ['element-variables.css', 'variable.css'];
    for (let i = 0, themeStsUILen = themeStsUI.length; i < themeStsUILen; i++) {
      if (excludeFiles.includes(themeStsUI[i])) continue;

      if (themeStsUI[i] === 'fonts') {
        // -R 递归处理  把 themeStsUIPath 下 fonts 所有文件 复制到 themeChalkPath 中
        shelljs.cp('-R', pathResolve(themeStsUIPath, 'fonts/*'), pathResolve(themeChalkPath, 'fonts'));
        continue;
      }

      if (themeStsUI[i] === 'assets') {
        // 把 themeStsUIPath 下 assets 目录文件 直接复制到 themeChalkPath
        shelljs.cp('-R', pathResolve(themeStsUIPath, 'assets'), themeChalkPath);
        continue;
      }

      if (themeChalk.includes(themeStsUI[i])) {
        // 说明当前样式文件是覆写 element-ui 中的样式
        const oldFileContent = fs.readFileSync(pathResolve(themeChalkPath, themeStsUI[i]), { encoding: 'utf-8' });
        fileSave(pathResolve(themeChalkPath, themeStsUI[i])).write(oldFileContent).write(fs.readFileSync(pathResolve(themeStsUIPath, themeStsUI[i])), 'utf-8').end();
      } else {
        // 说明当前样式文件是扩展的新组件的样式文件
        // fs.writeFileSync(pathResolve(themeChalkPath, themeStsUI[i]), fs.readFileSync(pathResolve(themeStsUIPath, themeStsUI[i])));
        shelljs.cp(pathResolve(themeStsUIPath, themeStsUI[i]), themeChalkPath);
      }
    }

    // 删除 lib/theme-pg
    shelljs.rm('-rf', themeStsUIPath);
    ``` 
    - 改造 package.json 文件中的 scripts
    ```json
    {
      "gen-cssfile:comment": "在 /packages/theme-pg/src/index.less 中自动引入各个组件的覆写样式文件",
      "gen-cssfile": "node build/bin/gen-cssfile",
      "build:theme:comment": "构建主题样式：在 index.less 中自动引入各个组件的覆写样式文件 && 通过 gulp 将 less 文件编译成 css 并输出到 lib 目录 && 拷贝基础样式 theme-chalk 到 lib/theme-chalk && 拷贝 编译后的 theme-pg/lib/* 目录到 lib/theme-pg && 合并 theme-chalk 和 theme-pg",
      "build:theme": "npm run gen-cssfile && gulp build --gulpfile packages/theme-pg/gulpfile.js && cp-cli packages/theme-pg/lib lib/theme-pg && cp-cli packages/theme-chalk lib/theme-chalk && node build/bin/compose-css-file.js",
    }
    ```
    - 执行以下命令
    ```shell
    npm run gen-cssfile
    ```
    - 改造 `/examples/entry.js`
    ```js
    // 引入自定义样式
    import 'packages/theme-pg/src/index.scss';
    ``` 
    - 启动开发环境，即可查看下个




